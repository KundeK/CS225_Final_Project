                                            CS 225 Final Project Written Report
                        By: Aadarsh Hegde, Shaarav Rotiwar, Shreyas Khati, and Krushank Bayyapu
In this project, we wanted to accomplish the goal of building real-world applications using the knowledge we gained throughout CS225 and the Openflights dataset provided to us. Our project consists of a fully-functional data-parsing pipeline, a PageRank algorithm to provide us with information about the most connected airport within the United States, and a Dijstrika’s algorithm which outputs the shortest path between two given airports.
First, in order to transform the information from the Openflights dataset into a graph structure for us to analyze, we needed to download both the airports.dat and routes.dat files from the Openflights database. This was to ensure we received the information needed to set up the airports as vertices and the distances of the routes for the edges in our graph. For each airport, the Openflights dataset stored an airport ID, airport name, and longitude and latitude coordinates. We parsed each line to ignore any missing data or data that was labeled as NULL. This made sure that our graph was devoid of any bugs or errors that would disrupt our algorithms. In addition, we created a helper function to convert the latitude and longitude coordinates into distances to allow us to label the edges in our graph. For the graph structure, we made a separate Vertex and Edge class, and to build our graph we used a map with an airport vertex as the key and the value being a map of vertices to edges, or airports to their respective distances from the original airport vertex.
Similarly, for Dijstrika’s algorithm, we intended for it to show us the shortest path between two airports. We had the function take in the source and destination vertices, and it would return a vector of edges. The runtime of this algorithm was O(N log N) where n was the number of vertices, which shows that the algorithm did not exceed the expected runtime. Dijkstra’s algorithm worked by traversing through a vertex(airport), looking at which neighbor would lead to the least cost, and continuing to that neighbor until the destination airport was reached. A priority queue was used in order to implement Dijkstra’s algorithm with an adjacency list, and maps were used to keep track of the previous nodes, distances, and a set for the visited nodes.
Likewise, the purpose of the PageRank algorithm was to see which airport was the most connected or the busiest within the United States. Traversing through each vertex and looking at the inlinks and outlinks for each one allowed us to create a map of vertices to doubles where the double variable represented the connectivity of a given airport. In addition, the PageRank algorithm essentially normalizes the rank of each vertex, allowing us to see how one vertex was more connected than other vertices comparatively. Likewise, the runtime for this algorithm did not exceed O(n+m) time, where n is the number of vertices and m is the number of edges. Given a large dataset, the runtime was slightly long, however, it works under the set runtime given the number of airports and routes. For testing purposes, we used a subset of the original data to see whether the output of this algorithm would still be the same, using fewer airports and routes but
keeping the most connected airport in the subset. Sure enough, the algorithm still outputted the same vertex, which was Denver International Airport as the most connected airport in the Openflights dataset. This result is consistent with real life as Denver International Airport is still one of the most connected airports to this day.
Our leading question was to learn more about the applications of optimizations in real-world situations, for example figuring out which airport is the most connected to other airports based on the number of outlinks each airport had. This was primarily done through the PageRank Algorithm, and the end result was that we found out that Denver International Airport was the more popular airport in the United States. We were able to achieve the shortest route from the input airport to the target airport in certain cases, but overall we did have some trouble when it came to implementing Diijsktras as the priority queue in order to maintain a min heap because the inequality operator could not properly compare the vertices. In the future, if we had to redo this project, rather than trying to use the in-built priority queue we would develop our own min-heap structure which would have allowed for proper comparison when creating the priority queue. However we were still able to complete a full data parsing pipeline, structure the data accordingly into a graph, and completely implement the Page Rank algorithm.